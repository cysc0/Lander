# META

## Team Members
Mike Sarfaty - sarfaty.m@husky.neu.edu  
Chris Gast - cpgast@gmail.com

## Deployment URL

[lander.zombo.club](http://lander.zombo.club/)

## Repo URL

[github.com/cysc0/lander](https://github.com/cysc0/lander)

## Project Status

All functionality (including deployment) is working as intended.

## Team Member Responsibilities

Mike Sarfaty:  
All game logic, including handling of game on server, and 
client view. This included generating the state for a game, 
and stripping down the view of it depending on the user role 
(spectator vs player). Set up all channels/topics for different 
game rooms. Integrated game w/ the rest of the frontend.

Chris Gast:  
Repo init, deployment, user sessions/logins/signups.
For the users, courses, and my scores page, implemented all 
frontend/backend logic. All api logic, including client<->maps 
api and server<->elevation api.

# APP

## What is it
This project is a game much like 
[moonlander](http://moonlander.seb.ly/)  
In the game itself, the goal is to navigate a ship to a certain 
part of the course to get certain levels of points. The user 
applies throttle and tilt to steer the ship to the ground 
safely, while landing at a minimal velocity.
Our app maintains tables w/in the database for users, courses, 
and user's game history. The courses are generated by users, 
allowing them to pick 2 points on a map, and the app then 
generates elevation data (interpolating ~200 points between 
those chosen points), and the terrain is build using that data.

## Requirements
**More ambitious than previous assignments:** our application 
incorporates all elements from previous SPA assignments, 
including authenticated user sessions, inter-relational DB 
tables, and channels/topics for user games. It also incorporates 
2 authenticated API's (google maps and google elevation). The game is also significantly more complicated than previous, as it handles game logic on the server, and represents the game state to the user via the react konva library.  
**Server side is Elixir/Phoenix:** yes  
**Significant back-end logic:** The non-game logic is as complicated as previous assignments, as it uses authenticated sessions, SPA setup, and AJAX requests for most server<->client interaction. Aside from the maps API implementation (and essential front-end logic), everything is handled in the back-end (including game logic, elevation API, database interaction, ...)  
**Deployed on our VPS:** the application is hosted on one of our VPS's  
**User accounts:** our application enables signups/logins using secured/hashed passwords  
**External API:** We use 2 API's. While the maps API implementation is client<->API, the elevation API meets the requirement of server<-> server. Both API's are authenticated.  
**Phoenix channels:** Our application uses phoenix channels for the game state.  
**Team size:** Our team consists of 2 members.

## Extra cool stuff
The coolest part of our project is the fact that spectators can interact with a player's game in a disruptive manner. They are able to destroy the terrain of the course, thereby making the player's job more difficult, and lowering the highest attainable score if the spectators strategize.

## Complex part
Just like the cool part, the challenging part was configuring the game to handle different types of input (course destructor vs player)

## Most significant challenge
The most challenging part was designing the game logic and client<->server interaction for the game to distinguish between different types of users. We have support for three roles. The player user is allowed to control their ship via throttle and tilt. The spectators are allowed to destroy terrain. Non-users can only watch, but this functionality has been disabled. Within the phoenix channels, all data of the current game state needs to be visible to all participants in the channel, but we needed to restrict certain inputs from these various roles.
