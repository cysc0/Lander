# META

## Team Members
Mike Sarfaty - sarfaty.m@husky.neu.edu  
Chris Gast - cpgast@gmail.com

## Deployment URL

[lander.zombo.club](http://lander.zombo.club/)

## Repo URL

[github.com/cysc0/lander](https://github.com/cysc0/lander)

## Project Status

All functionality (including deployment) is working as intended.

## Team Member Responsibilities

Mike Sarfaty:  
All game logic, including handling of game on server, and 
client view. This included generating the state for a game, 
and stripping down the view of it depending on the user role 
(spectator vs player). Set up all channels/topics for different 
game rooms. Integrated game w/ the rest of the frontend.
Tweaked the rest of the front end as needed for integration.

Chris Gast:  
Repo init, deployment, user sessions/logins/signups.
For the users, courses, and my scores page, implemented all 
frontend/backend logic. All api logic, including client<->maps 
api and server<->elevation api.

# APP

## What is it
This project is a game much like 
[moonlander](http://moonlander.seb.ly/)  
In the game itself, the goal is to navigate a ship to a certain 
part of the course to get certain levels of points. The user 
applies throttle and tilt to steer the ship to the ground 
safely, while landing at a minimal velocity.
Our app maintains tables w/in the database for users, courses, 
and user's game history. The courses are generated by users, 
allowing them to pick 2 points on a map, and the app then 
generates elevation data (interpolating ~200 points between 
those chosen points), and the terrain is built using that data.

## Requirements
**More ambitious than previous assignments:** our application 
incorporates all elements from previous SPA assignments, 
including authenticated user sessions, inter-relational DB 
tables, and channels/topics for user games. It also incorporates 
2 authenticated API's (google maps and google elevation). The game 
is also significantly more complicated than previous, as it 
handles game logic on the server, and represents the game state 
to the user via the react konva library.  
**Server side is Elixir/Phoenix:** yes  
**Significant back-end logic:** The non-game logic is as 
complicated as previous assignments, as it uses authenticated 
sessions, SPA setup, and AJAX requests for most server<->client 
interaction. Aside from the maps API implementation (and essential 
front-end logic), everything is handled in the back-end (including 
game logic, elevation API, database interaction, ...)  
**Deployed on our VPS:** the application is hosted on one of 
our VPS's  
**User accounts:** our application enables signups/logins using 
secured/hashed passwords  
**External API:** We use 2 API's. While the maps API 
implementation is client<->API, the elevation API meets the 
requirement of server<-> server. Both API's are authenticated.  
**Phoenix channels:** Our application uses phoenix channels for 
the game state. This handles input from the player, and it is 
also responsible for handling terrain destruction from spectators.  
**Team size:** Our team consists of 2 members.

## Extra cool stuff
The coolest part of our project is the fact that spectators can 
interact with a player's game in a disruptive manner. They are 
able to destroy the terrain of the course, thereby making the 
player's job more difficult, and lowering the highest attainable 
score if the spectators strategize. This is implemented via
phoenix channels.

## Complex part
Just like the cool part, the challenging part was configuring the 
game to handle different types of input (course destructor vs 
player).

## Most significant challenge
The most challenging part was designing the game logic and 
client<->server interaction for the game to distinguish between 
different types of users. We have support for three roles. The 
player user is allowed to control their ship via throttle and 
tilt. The spectators are allowed to destroy terrain. Non-users 
can only watch, but this functionality has been disabled. Within 
the phoenix channels, all data of the current game state needs to 
be visible to all participants in the channel, but we needed to 
restrict certain inputs from these various roles.
